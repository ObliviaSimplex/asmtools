
int code_call ( u8 *code, u64 *raxtrace ){
  // we'll start with some basic shellcode-testing
  // boilerplate. 
  long (*ret)() = (long(*)())code;

  int status;

  pid_t pid;
  pid = fork();
  
  if (pid == 0){ // if in child process (tracee)

    ptrace(PTRACE_TRACEME, 0, NULL, NULL);
    ret(32,64);
    kill(getpid(), SIGSTOP);
    exit(1);
    
  } else {      // if in parent process (tracer)
    
    int status;
    /* union u { */
    /*   u64 val; */
    /*   u8 bytes[sizeof(u64)]; */
    /* }data; */
    struct user_regs_struct regs;
    int start = 1;
    long ins;
    //    while(1){
      
      wait(&status);
      
      //ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL);
           
      /* Now for the actual tracing */
     
         
      ptrace(PTRACE_GETREGS, pid, NULL, &regs);
      print_registers(regs);
      
      /* if (start == 1) { */
      /*   ins = ptrace(PTRACE_PEEKTEXT, pid, regs.rip, NULL); */
      /*   printf("\nRIP: %lx Instruction executed: %lx\n", */
      /*          regs.rip, ins); */
      /* } */
      
      
      if (WTERMSIG(status) == SIGSEGV){
        fprintf(stderr, "-- SEGFAULT --\n"); // not detecting it
        //  break;
      }
      /* If the child has exited cleanly or been killed
       * then break out of the loop and exit.
       */
      if (WIFEXITED(status) || WIFSIGNALED(status)){
        fprintf(stderr, "Child exited with status %d\n", status);
        //break;
      }
      
      // }
    
    
  }
  return status;
          
}
